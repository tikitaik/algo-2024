- as many points in time limit

task :  
|   define model to hold required information for an event
|   develop algo for optimal path through the park
|   use the model to compare team efficiency

event
|   
|   node<checkpoint> <- start checkpoint
|   node<checkpoint> <- end checkpoint 
|   integer timeLimit <- time limit in minutes
|   graph <- event map with only nodes, no edges
|   linked list <- checkpoints
|   linked list <- teams
|   array<linkedList<teams> > size 6 <- brackets
|   dictionary <checkpoint, linked list<pair <team, time> > > <- checkpoint register
|
|   name event
|   import graph, linked list, index, team, checkpoint, time
|   
|   operations
|   newEvent: graph, start coordiantes, end coordinates, checkpoint linked list -> event
|   addTeamToBracket: event x team x index -> event
|   addTeamToCheckpoint: event x checkpoint x team x time -> event
|   pathBackInTimeExists: event x graph x node x node x node x time -> boolean
|   pathBackFromNeighbourExists: event x graph x node x node x time -> boolean
|   optimalRouteForBracket: event x team -> linkedlist of nodes
 
team ADT
|   int <- team member count
|   linkedList<pairs<string, age> > <- team member names and ages
|   time <- time of arrival 
|   time <- finishing time
|   armband register (linkedList of pairs <checkpoint, time visited>)
|   float <- average speed
|   integer <- bracket index
|
|   name team
|   import linked list, time, checkpoint
|   
|   operations
|   newTeam: linked list (empty and can be added later, or partially/ fully filled with members) -> team
|   teamSize: team -> int
|   teamMembers: team -> linkedlist of teams
|   setStartTime: team x time -> team
|   setEndTime: team x time -> team
|   getElapsedTime: team -> time
|   addCheckpointToArmband: team x checkpoint -> team

checkpoint ADT
|   pair<int, int> <- x and y coordinates in pixels
|   int <- point reward
|
|   name checkpoint
|   import integer, pair
|   
|   operations
|   newCheckpoint: integer x integer x int -> checkpoint
|   getLocation: checkpoint -> pair of integers
|   getPoints: checkpoint -> int

other signatures

linked list ADT
|   name linked list
|   import element, integer
|   
|   operations
|   newLinkedList: -> linked list
|   insertTail: element x linked list -> linked list
|   insertHead: element x linked list -> linked list
|   removeKey: element x linked list -> linked list
|   size: linked list -> integer
|   head: linked list -> element

graph ADT
|   name graph
|   import node, edge, attribute, integer, bool
|   
|   operations
|   newGraph: -> graph
|   allNodes: graph -> linked list of nodes
|   allEdges: graph -> linked list of edges
|   nodeCount: graph -> integer
|   edgeCount: graph -> integer
|   addNode: graph x node x attribute -> graph
|   addNodes: graph x integer -> graph
|   addEdge: graph x edge -> graph
|   deleteNode: graph x node -> graph
|   deleteEdge: graph x edge -> graph
|   neighbours: graph x node -> linked list of nodes
|   untraversedNeighbours: graph x node -> linked list of nodes
|   degree: graph x node -> integer
|   edgeExists: graph x edge: bool
|   setAllNodesToUntraversed: graph -> graph
|   getTraversedState: graph -> graph
|   resetTraversed: graph -> graph
|   allNodesAreTraversed: graph -> bool
|   connected: graph -> bool
|   cyclic: graph -> bool

pair
|   name pair
|   import element type 1, element type 2
|   operations 
|   newPair: element type 1 x element type 2 -> pair

dictionary
|   name dictionary
|   import key, value
|
|   operations
|   newDictionary: -> dictionary
|   insert: key x value -> dictionary
|   remove: key -> dictionary
|   getValue: dictionary x key -> value
|   changeValue: dictionary x key x value -> dictionary

SYSTEM FOR IDS OF CHECKPOINTS: ID INCREASES FROM BOTTOM (real south) OF THE LEFT MOST NORTH LINES COLUMN
-   SO BOTTOM (actual south) CHECKPOINT IN LEFT MOST COLUMN HAS ID 1
-   TOP (most actual north) CHECKPOINT IN RIGHT MOST COLUMN HAS ID 38
-   HASH HOUSE has id of 0 and point reward of 0

time estimate function
-   coordinates for start and end: used to give baseline time/ distance
-   isUphill int: used to multiply time by 1.25 if uphill (1) or 0.833 if downhill (-1) or do nothing if neutral
-   road coefficient: the percentage of time that could be spent on the road in the optimal route
-   obstacle coefficient: percentage of time spent not moving towards goal due to obstacles. As such should never equal 1
    if 0 then no extra time for crossings
-   add 2 minutes on each edge for finding scanning point

algorithm
-   assign each node a 'desirability' attribute (could be in an array) (could be based on a bunch of factors like closeness to hash house, and quality of nodes around it)
-   multiple depth recursive desirability check?
-   from hash house follow desirable nodes as long as a path exists back to the hash house in less time than is left 

algorithm pseudocode

start float DESIRABILITY (map, currentNode, depth)
    if depth = 1
        desirability <- 0
        for each neighbour in rogaine map of currentNode
            desirability <- desirability + neighbourNode.pointReward / edgeWeight(CurrentNode, neighbourNode)
        end for
        
        return desirability
    else
        desirability <- 0
        for each neighbour node of currentNode
            desirability <- desirability + DESIRABILITY(neighbourNode, depth - 1)
        end for

        return desirability / depth
    end if
stop

start integer GET_PATH_TIME (startNode, endNode, walkSpeed, uphill, roadCoefficient, obstacleCoefficient)
    if roadCoefficient > 1 or roadCoefficient < 0
        return null
    if obstacleCoefficient >= 1 or obstacleCoefficient < 0
        return null

    meter <- 1 / 0.190

    distance <- sqrt((startNode.x - endNode.x)^2 + (startNode.y - endNode.y)^2) * meter
    distance <- distance * (roadCoefficient + (1 - roadCoefficient) * 1 / 0.7)
    distance <- distance / obstacleCoefficient

    if uphill > 0
        distance <- distance / 0.8
    else if uphill < 0
        distance <- distance / 1.2

    edgeTime <- distance / walkSpeed
    edgeTime <- edgeTime / 60
    round edgeTime to neartest integer
    return edgeTime
stop

start bool PATH_BACK_IN_TIME_EXISTS (teamMap, currentNode, possibleNode, goalNode, timeLimit)
    timeLimit <- timeLimit - edgeWeight(sourceNode, currentNode)
    if possible node is untraversed
        timeLimit <- timeLimit - 2
    end if

    teamMap.getTraversedState()
    teamMap.setAllNodesToUntraversed()
    path cost <- 0

    for each untraversed node in the shortest path back to goalNode
        path cost <- path cost + 2
    end for

    path cost <- djikstrasCost(currentNode, goalNode)

    g.resetTraversed()
    if (pathCost > timeLimit)
        return false
    else
        return true
    end if
stop

start bool PATH_BACK_FROM_NEIGHBOUR_EXISTS (teamMap, currentNode, goalNode, timeLimit)
    for each neighbour of currentNode
        if PATH_BACK_IN_TIME_EXISTS(teamMap, currentNode, neighbourNode, goalNode, timeLimit)
            return true
        end if
    end for

    return false
stop

start linkedList OPTIMAL_ROUTE (team)
    walkSpeed <- team.speed
    for i <- team.bracket to 5
        walkSpeed <- walkSpeed / 0.973
    end for

    graph teamMap <- constructGraph(walkSpeed)
    currentNode <- hash house
    endCheckpoint <- hash house
    linkedList path <- empty list
    pointTotal <- 0

    desirability array <- empty array size teamMap.nodeCount()
    for i <- 0 to checkpoint count - 1
        desirability[i] <- DESIRABILITY(teamMap, node with id i, 6)
    end for

    insert currentNode to path

    while PATH_BACK_FROM_NEIGHBOUR_EXISTS(teamMap, currentNode, hash house, timeRemaining)
        currentNode.traversed <- true
        node bestNode
        for each neighbour of currentNode
            if bestNode is null and PATH_BACK_IN_TIME_EXISTS(teamMap, currentNode, neighbourNode, hash house, timeRemaining) = true
                bestNode <- neighbourNode
            else if best node is null and PATH_BACK_IN_TIME_EXISTS(teamMap, currentNode, neighbourNode, hash house, timeRemaining) = false
                continue
            else if desirability array[bestNode] < desirability array[neighbourNode] and PATH_BACK_IN_TIME_EXISTS(teamMap, currentNode, neighbourNode, hash house, timeRemaining) = true
                bestNode <- neighbourNode
            end if
        end for

        timeRemaining <- timeRemaining - edgeWeight(currentNode, bestNode)
        if bestNode.traversed = true
            timeRemaining <- timeRemaining - 2
        end if
        desirability[currentNode] <- 0

        currentNode <- bestNode
        insert currentNode to path
        if desirability[currentNode] != 0
            pointTotal <- pointTotal + currentNode.points
        end if
    end while

    if timeRemaining < 0
        pointTotal <- pointTotal + timeRemaining * 10
    end if

    return path
stop
