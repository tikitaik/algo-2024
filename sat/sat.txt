- as many points in time limit

task :  
|   define model to hold required information for an event
|   develop algo for optimal path through the park
|   use the model to compare team efficiency

event
|   
|   node<checkpoint> <- start checkpoint
|   node<checkpoint> <- end checkpoint 
|   linked list <- teams
|   array<linkedList<teams> > size 6 <- brackets
|   dictionary <checkpoint, linked list<pair <team, time> > > <-- checkpoint register
|
|   name event
|   import graph, linked list, index, team, checkpoint
|   
|   operations
|   newEvent: graph, start coordiantes, end coordinates, checkpoint linked list -> event
|   addTeamToBracket: event x team x index -> event register
|   optimalRouteForBracket: event x index -> linkedlist of nodes
|   addTeamToCheckpoint: event x checkpoint x team x time -> event
 
team ADT
|   int <- team member count
|   linkedList<pairs<string, age> > <- team member names and ages
|   time <- time of arrival 
|   time <- finishing
|   armband register (linkedList of pairs <checkpoint, time visited>)
|
|   name team
|   import linked list, time, checkpoint
|   
|   operations
|   newTeam: linked list (empty and can be added later, or partially/ fully filled with members) -> team
|   teamSize: team -> int
|   teamMembers: team -> linkedlist of teams
|   setStartTime: team x time -> team
|   setEndTime: team x time -> team
|   getElapsedTime: team -> time
|   addCheckpointToArmband: team x checkpoint -> team

checkpoint ADT
|   pair<int, int> <- x and y coordinates
|   int <- point reward
|
|   name checkpoint
|   import float
|   
|   operations
|   newCheckpoint: float x float x int -> checkpoint
|   getLocation: checkpoint -> pair of floats
|   getPoints: checkpoint -> int

other signatures

linked list ADT
|   name linked list
|   import element
|   
|   operations
|   newLinkedList: -> linked list
|   insertTail: element x linked list -> linked list
|   insertHead: element x linked list -> linked list
|   removeKey: element x linked list -> linked list
|   size: linked list -> int
|   head: linked list -> element

graph ADT
|   name graph
|   import node, edge, attribute
|   
|   operations
|   newGraph: -> graph
|   allNodes: graph -> linked list of nodes
|   allEdges: graph -> linked list of edges
|   nodeCount: graph -> int
|   edgeCount: graph -> int
|   addNode: graph x node x attribute -> graph
|   addNodes: graph x int -> graph
|   addEdge: graph x edge -> graph
|   deleteNode: graph x node -> graph
|   deleteEdge: graph x edge -> graph
|   neighbours: graph x node -> linked list of nodes
|   untraversedNeighbours: graph x node -> linked list of nodes
|   incident: graph x node -> linked list of nodes
|   degree: graph x node -> int
|   edgeExists: graph x edge: bool
|   setAllNodesToUntraversed: graph -> graph
|   allNodesAreTraversed: graph -> bool
|   connected: graph -> bool
|   cyclic: graph -> bool

pair
|   name pair
|   import element type 1, element type 2
|   operations 
|   newPair: element type 1 x element type 2-> pair

dictionary
|   name dictionary
|   import key, value
|   operations
|   newDictionary: -> dictionary
|   insert: key x value -> dictionary
|   remove: key -> dictionary
|   getValue: key -> value
|   changeValue: key x value -> dictionary

SYSTEM FOR IDS OF CHECKPOINTS: ID INCREASES FROM BOTTOM (real south) OF THE LEFT MOST NORTH LINES COLUMN
-   SO BOTTOM (actual south) CHECKPOINT IN LEFT MOST COLUMN HAS ID 1
-   TOP (most actual north) CHECKPOINT IN RIGHT MOST COLUMN HAS ID 38
-   HASH HOUSE has id of 0 and point reward of 0

time estimate function
-   coordinates for start and end: used to give baseline time/ distance
-   isUphill int: used to multiply time by 1.25 if uphill (1) or 0.833 if downhill (-1) or do nothing if neutral
-   road coefficient: the percentage of time that could be spent on the road in the optimal route
-   obstacle coefficient: percentage of time spent not moving towards goal due to obstacles. As such should never equal 1
    if 0 then no extra time for crossings
-   add 2 minutes on each edge for finding scanning point

algorithm
-   assign each node a 'desirability' attribute (could be in an array) (could be based on a bunch of factors like closeness to hash house, and quality of nodes around it)
-   multiple depth recursive desirability check?
-   from hash house follow desirable nodes as long as a path exists back to the hash house in less time than is left 

algorithm pseudocode

start float DESIRABILITY (node currentNode, depth)
    if depth = 1
        desirability <-- 0
        for each neighbour in rogaine map of currentNode
            desirability <-- desirability + neighbourNode.pointReward / edgeWeight(CurrentNode, neighbourNode)
        end for
        
        return desirability
    else
        desirability <-- 0
        for each neighbour node of currentNode
            desirability <-- desirability + DESIRABILITY(neighbourNode, depth - 1)
        end for

        return desirability / depth
    end if
stop

start integer GET_PATH_TIME (startNode, endNode, walkSpeed, uphill, roadCoefficient, obstacleCoefficient)
    if roadCoefficient > 1 or roadCoefficient < 0
        return -1
    if obstacleCoefficient >= 1 or obstacleCoefficient < 0
        return -1

    meter <-- 1 / 0.190

    distance <-- sqrt((startNode.x - endNode.x)^2 + (startNode.y - endNode.y)^2) * meter
    distance <-- distance * (roadCoefficient + (1 - roadCoefficient) * 1 / 0.7)
    distance <-- distance / obstacleCoefficient

    if uphill > 0
        distance <-- distance / 0.8
    else if uphill < 0
        distance <-- distance / 1.2

    edgeTime <-- distance / walkSpeed
    edgeTime <-- edgeTime / 60
    round edgeTime to neartest integer
    return edgeTime
stop

start bool PATH_BACK_IN_TIME_EXISTS (sourceNode, possibleNode, goalNode, timeLimit)
    timeLimit <-- timeLimit - edgeWeight(sourceNode, possibleNode)

    if (djikstrasCost(possibleNode, goalNode) > timeLimit)
        return false
    else
        return true
    end if
stop

start bool PATH_BACK_FROM_NEIGHBOUR_EXISTS (currentNode, goalNode, timeLimit)
    for each neighbour of currentNode
        if PATH_BACK_IN_TIME_EXISTS(neighbourNode)
            return true
        end if
    end for

    return false
stop

start linkedList OPTIMAL_ROUTE (bracket)
    timeRemaining <-- timeLimit * pow(1.027, 5 - bracket)
    currentNode <-- hash house
    endCheckpoint <-- hash house

    linkedList path
    int pointTotal

    desirability array
    for i <-- 0 to checkpoint count
        desirability[i] <-- DESIRABILITY(node with id i, depth 6)
    end for

    insert currentNode to path

    while PATH_BACK_FROM_NEIGHBOUR_EXISTS(currentNode, hash house, timeRemaining) or (djikstrasCost(currentNode, hash house) < time remaining and currentNode != hash house)
        node bestNode
        for each neighbour of currentNode
            if bestNode is null and PATH_BACK_IN_TIME_EXISTS(currentNode, neighbourNode, hash house, timeRemaining) = true
                bestNode <-- neighbourNode
            else if best node is null and PATH_BACK_IN_TIME_EXISTS(currentNode, neighbourNode, hash house, timeRemaining) = false
                continue
            else if desirability array[bestNode] < desirability array[neighbourNode] and PATH_BACK_IN_TIME_EXISTS(currentNode, neighbourNode, hash house, timeRemaining) = true
                bestNode <-- neighbourNode
            end if
        end for

        timeRemaining <-- timeRemaining - edgeWeight(currentNode, bestNode)
        desirability[currentNode] <-- 0

        currentNode <-- bestNode
        insert currentNode to path
        if desirability[currentNode] != 0
            pointTotal <-- pointTotal + currentNode.points
        end if
    end while

    return path
stop
